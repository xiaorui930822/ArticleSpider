[{"tags": "IT技术,LLVM,语言", "comment_nums": 0, "content": "<div class=\"entry\">\r\n\r\n        \t\t\t<div class=\"textwidget\"></div>\n\t\t\r\n\t\t<div class=\"copyright-area\">原文出处： <a ref=\"nofollow\" target=\"_blank\" href=\"https://www.infoworld.com/article/3247799/development-tools/what-is-llvm-the-power-behind-swift-rust-clang-and-more.html\">Serdar Yegulalp</a>   译文出处：<a target=\"_blank\" href=\"https://www.oschina.net/translate/what-is-llvm-the-power-behind-swift-rust-clang-and-more\">开源中国翻译</a>   </div><p><img class=\"aligncenter\" src=\"http://jbcdn2.b0.upaiyun.com/2018/02/7130c496b853a379b7b91ff9ce0f5a26.jpg\"></p>\n<blockquote><p>要了解用于以编程方式生成机器原生代码的编译器框架是如何让新语言的推出以及对现有的语言进行增强比以往更加容易了。</p></blockquote>\n<p>新的语言，还有对现有语言的提升，在整个编程环境中正大行其道。<a href=\"https://www.infoworld.com/article/3234929/application-development/get-started-with-rust-the-language-for-safer-code.html\" rel=\"nofollow\">Mozilla 的 Rust</a>、<a href=\"https://www.infoworld.com/article/3216546/application-development/what-to-expect-in-apples-swift-5.html\" rel=\"nofollow\">Apple 的 Swift</a>、<a href=\"https://www.infoworld.com/article/3224868/java/what-is-kotlin-the-java-alternative-explained.html\" rel=\"nofollow\">Jetbrains 的 Kotlin</a>，以及许多其它的语言都给开发者在速度、安全性、便利性、可移植性还有能力这些方面提供了新的选择。</p>\n<p>为什么现在正当时呢？一个大因素就是那些用来构建语言的新工具，特别是编译器。它们中首当其冲就是 LLVM （底层虚拟机 Low-Level Virtual Machine），这是一个开源项目，最开始作为伊利诺伊州大学的一个研究项目由 Swift 语言的创始人 Chris Lattner 进行开发。</p>\n<p>LLVM 使创建新语言变得更加容易，同时也可以增强现有语言的开发。它提供了一些工具，用于自动执行语言创建任务中最不讨人喜欢的部分：创建一个编译器，将输出的代码移植到多个平台和架构，编写代码来处理常见的语言隐喻，比如异常。它的自由授权意味着它可以自由地作为软件组件重用或作为服务部署。</p>\n<p>使用 LLVM 的语言名册中有许多熟悉的名字。苹果的 Swift 语言使用 LLVM 作为它的编译器框架，而 Rust 则将 LLVM 作为其工具链的核心组件。而且，许多编译器都有一个 LLVM 版本，如 Clang、C/C++ 编译器（这个名称叫做“C-lang”)，它本身就是一个与 LLVM 紧密相连的项目。而 Kotlin，名义上是一种 JVM 语言，正在开发一种名为 <a href=\"https://www.infoworld.com/article/3187370/application-development/kotlin-compiles-directly-to-native-code-via-llvm.html\" target=\"_blank\" rel=\"nofollow\">Kotlin Native</a> 的语言版本，它使用 LLVM 来编译成机器原生代码。</p>\n<h2>LLVM 定义</h2>\n<p>在它的核心，LLVM 是一个以编程方式创建机器原生代码的库。开发人员使用该 API 以一种称为中间代理或 IR 的格式生成指令。然后 LLVM 可以将 IR 编译成一个独立的二进制文件，或者在另一个程序（如语言解释器）的上下文中执行 JIT (just-in-time) 编译。</p>\n<p>LLVM 的 API 为开发在编程语言中发现的许多常见结构和模式提供了原始的方式。例如，几乎每种语言都有函数和全局变量的概念。LLVM 将函数和全局变量作为其 IR 中的标准元素，因此，你只需在意 LLVM 的实现，并关注需要注意的语言部分，而不是花费时间和精力重新创建这些特定的轮子。</p>\n<p style=\"text-align: center\"><img src=\"http://jbcdn2.b0.upaiyun.com/2018/02/1ab6717058da2c9d3319acd96bfc5274.jpg\"></p>\n<p style=\"text-align: center\"><em>这是一个 LLVM 中间代理(IR)的例子。右边是一个简单的 C 程序；左边是由 Clang 编译器翻译成 LLVM IR 的代码。</em></p>\n<h2>LLVM：专为可移植性而生</h2>\n<p>关于 LLVM 的一个说法是它像常提到的 C 编程语言：C 语言有时候被认为是一种便携式、高级的汇编语言，因为它可以紧密地映射到系统硬件的结构，而且它已经被移植到几乎所有的系统架构。但是，C 语言只是作为一种可移植的汇编语言，是其工作方式的另一种效果；这并不是它的设计目标之一。</p>\n<p>相比之下，LLVM 的 IR 是从一开始就设计为可移植的组件。它实现这种可移植性的一种方法是提供独立于任何特定机器架构的原语。例如，整数类型不局限于底层硬件的最大位宽度(例如 32 或 64 位)，您可以根据需要使用尽可能多的比特字节来创建基本的整数类型，比如 128 位整数。您也不必担心手工输出来匹配特定处理器的指令集；LLVM 也会为你处理这个问题。</p>\n<p>如果你希望看到 LLVM IR 的现场示例，请访问 <a href=\"http://ellcc.org/\" target=\"_blank\" rel=\"nofollow\">ELLCC 项目网站</a>，并尝试在浏览器中将 C 代码转换为 LLVM IR 的<a href=\"http://ellcc.org/demo/index.cgi\" target=\"_blank\" rel=\"nofollow\">现场演示 Demo</a>。</p>\n<h2>编程语言中如何使用 LLVM</h2>\n<p>LLVM 最常见的用例是作为一种语言的预先(AOT ahead-of-time)编译器。但 LLVM 也可以用于即时编译。</p>\n<h3><strong><strong>用 LLVM 进行即时</strong>编译</strong></h3>\n<p>有些情况下需要在运行时动态生成代码，而不是预先编译。例如，<a href=\"https://www.infoworld.com/article/3241107/python/julia-vs-python-julia-language-rises-for-data-science.html?nsdr=true\" rel=\"nofollow\">Julia 语言</a>就是使用 JIT 编译代码，因为它需要快速运行，并通过 REPL（read-eval-print loop）或交互式提示与用户交互。.Net 和 Mono 可以选择通过 <a href=\"http://www.mono-project.com/docs/advanced/runtime/docs/llvm-backend/\" rel=\"nofollow\">LLVM 后端方式编译为原生代码</a>。</p>\n<p><a href=\"https://www.infoworld.com/article/2880767/python/5-projects-push-python-performance.html\" rel=\"nofollow\">Numba</a> 是一个 Python 的数学加速包，JIT 将所选择的 Python 函数编译成机器码。它也可以预先编译使用 Numba 装饰器装饰的代码，但是（比如 Julia）Python 作为一种快速发展的解释性语言，使用 JIT 编译来产生这样的代码更好地补充了 Python 的交互式工作流，比 Python 的预先编译方式更好。</p>\n<p>其他人正在尝试以非正统方式使用 LLVM 作为 JIT 编译方式，例如<a href=\"https://www.pgcon.org/2017/schedule/events/1092.en.html\" rel=\"nofollow\">编译 PostgreSQL 查询</a>，据说性能提高了五倍。</p>\n<p style=\"text-align: center\"><img class=\"aligncenter\" src=\"http://jbcdn2.b0.upaiyun.com/2018/02/c08bb08efd2fb383b4669ece0643ac37.jpg\"><br>\n<em>Numba 使用 LLVM 进行即时编译数字代</em><em>码并加速其执行。JIT 加速过的 sum2d 函数的执行速度比常规 Python 代码快 139 倍。</em></p>\n<h3>使用 LLVM 进行自动代码优化</h3>\n<p>LLVM 不仅将 IR 编译为原生机器码。你也可以直接以编程的方式在整个链接过程中高度精细地优化代码。优化方式是相当积极主动的，能够实现包括内联函数在内，消除死代码（包括未使用的类型声明和函数参数）和展开循环这些事情。</p>\n<p>这里再一次强调，LLVM 的力量让你不必自己实现所有这一切。LLVM 可以为您处理它们，您也可以根据需要直接禁用。例如，如果你想要一些更小的二进制代码，那么你可以让你的编译器告诉 LLVM 禁用循环展开。</p>\n<h3>使用 LLVM 的领域特定语言</h3>\n<p>LLVM 已被用于生成多种通用语言的编译器，但它也可用于生成高度垂直或排他性问题域的语言。从某种意义上说，这就是 LLVM 最闪光的地方，因为它在创造这样一类语言方面消除了诸多苦差事，并使其表现良好。</p>\n<p>例如，<a href=\"https://github.com/kripken/emscripten\" target=\"_blank\" rel=\"nofollow\">Emscripten</a> 项目采用 LLVM IR 代码并将其转换为 JavaScript，理论上支持使用 LLVM 作为后端的任何语言导出可在浏览器中运行的代码。长期规划是支持基于 LLVM 的后端并能够生成 WebAssembly 代码，Emscripten 是 LLVM 灵活性的一个很好的例子。</p>\n<p>LLVM 可以被使用的另一种方法是将特定领域的扩展添加到现有语言。Nvidia 使用 LLVM 创建了 <a href=\"https://developer.nvidia.com/cuda-llvm-compiler\" target=\"_blank\" rel=\"nofollow\">Nvidia CUDA</a> 编译器，该编译器允许语言为 CUDA 添加原生支持，它是作为你生成的原生代码的一部分编译的，而不是通过附带的库进行调用的。</p>\n<h2>在不同语言中使用 LLVM</h2>\n<p>使用 LLVM 的典型方式是通过你所熟悉的语言来编写代码（当然也要有支持 LLVM 的库）。</p>\n<p>两种常见的可选语言是 C 和 C++。许多 LLVM 开发者会因为以下的原因而默认选择其中的一个：</p>\n<ul>\n<li>LLVM 本身是用 C++ 编写的</li>\n<li>LLVM 的 API 以 C 和 C++ 版本提供</li>\n<li>大量的语言开发往往会以 C/C++ 作为一个基础</li>\n</ul>\n<p>不过，这两种语言并不是唯一的选择。许多语言都可以原生调用 C 语言库，所以理论上可以用任何这样的语言进行 LLVM 开发。但需要有一个实际的语言库可以很好地封装 LLVM API。幸运的是，许多语言和语言运行时都有这样的库，包括 <a href=\"https://github.com/Microsoft/LLVMSharp\" rel=\"nofollow\">C#/.Net/Mono</a>, <a href=\"https://crates.io/crates/llvm-sys\" rel=\"nofollow\">Rust</a>, <a href=\"https://hackage.haskell.org/package/llvm\" rel=\"nofollow\">Haskell</a>, <a href=\"https://opam.ocaml.org/packages/llvm/\" rel=\"nofollow\">OCAML</a>, <a href=\"https://www.npmjs.com/package/llvm-node\" rel=\"nofollow\">Node.js</a>, <a href=\"https://llvm.org/svn/llvm-project/llgo/trunk/README.TXT\" rel=\"nofollow\">Go</a>, 和 <a href=\"https://github.com/numba/llvmlite\" rel=\"nofollow\">Python</a>。</p>\n<p>需要注意的是，一些与 LLVM 的语言绑定可能不完整。以 Python 为例，有很多种绑定选择，但每个选项的完整性和实用性各不相同：</p>\n<ul>\n<li>LLVM 项目<a href=\"https://github.com/llvm-mirror/llvm/tree/master/bindings/python\" rel=\"nofollow\">维护着自己的一套</a>到 LLVM 的 C API 的绑定，但是目前他们没有继续维护。</li>\n<li><a href=\"https://github.com/llvmpy/llvmpy\" rel=\"nofollow\">llvmpy</a> 在 2015 年后就没有进行维护了 —— 这对于任何软件项目都是不利的，在使用 LLVM 时更是如此，因为每个版本的 LLVM 都有一些变化。</li>\n<li>由创建 Numba 的团队开发的 <a href=\"https://github.com/numba/llvmlite\" rel=\"nofollow\">llvmlite</a> 已经成为当前在 Python 中的 LLVM 的竞争者。它只实现了 LLVM 功能的一个子集，正如 Numba 项目的需求所规定的那样。但是这个子集满足了绝大多数 LLVM 用户所需。</li>\n<li><a href=\"https://github.com/revng/llvmcpy\" rel=\"nofollow\">llvmcpy</a> 旨在为 C 库带来最新的 Python 绑定，它以自动化的方式保持更新，并使用 Python 的习惯用法来访问它们。llvmcpy 还处于早期阶段，但是已经可以用 LLVM API 做一些基本的工作。</li>\n</ul>\n<p>如果你对如何使用 LLVM 库构建语言感兴趣，不妨看看 LLVM 的创建者撰写的使用 C++ 或 OCAML 语言的<a href=\"https://llvm.org/docs/tutorial/index.html\" rel=\"nofollow\">教程</a>，它将一步步指导你创建一种简单的名为 Kaleidoscope 的语言。它还被移植到其他语言之上：</p>\n<ul>\n<li><strong><a href=\"http://www.stephendiehl.com/llvm/\" rel=\"nofollow\">Haskell</a></strong>：参考原始教程的直接移植。</li>\n<li><strong>Python</strong>：<a href=\"https://github.com/eliben/pykaleidoscope\" rel=\"nofollow\">在此网站的教程</a>和原始版本非常相近，而另一个版本则是用交互式命令行进行更为雄心勃勃的<a href=\"https://github.com/frederickjeanguerin/pykaleidoscope\" rel=\"nofollow\">重写</a>。这两种版本都使用 llvmlite 作为到 LLVM 的绑定。</li>\n<li><strong><a href=\"https://github.com/jauhien/iron-kaleidoscope\" rel=\"nofollow\">Rust</a> 和 <a href=\"https://harlanhaskins.com/2017/01/08/building-a-compiler-with-swift-in-llvm-part-1-introduction-and-the-lexer.html\" rel=\"nofollow\">Swift</a></strong>：不可避免地，我们不得不将该教程移植到这两种语言之上，它们都是由 LLVM 自身帮助使其诞生的。</li>\n</ul>\n<p>最后，这个教程也有其他国家语言版本的。这里有中文版，分别是使用<a href=\"https://github.com/liancheng/llvm-tutorial-cn\" target=\"_blank\" rel=\"nofollow\">原始的 C++</a> 和 <a href=\"https://github.com/moevis/Kaleidoscope-LLVM-tutorial-zh-cn\" target=\"_blank\" rel=\"nofollow\">Python</a> 版本。</p>\n<h2>LLVM 尚未实现的功能</h2>\n<p>了解 LLVM 可以实现的功能的同时，有必要知道 LLVM 目前尚未实现的功能。</p>\n<p>例如，LLVM 不解析语言的语法。因为目前已经有许多工具实现这个功能，比如 <a href=\"http://dinosaur.compilertools.net/\" rel=\"nofollow\">lex/yacc</a>, <a href=\"http://aquamentus.com/flex_bison.html\" rel=\"nofollow\">flex/bison</a>，以及<a href=\"http://www.antlr.org/\" rel=\"nofollow\">ANTLR</a>。解析语法就意味着必须从编译中解耦出来，难怪 LLVM 并没有涉及这个领域。</p>\n<p>LLVM 也不会直接干涉到开发语言的软件文化，比如安装编译器的二进制文件、如何在安装中管理软件包、升级工具链 —— 这些都需要开发者自己去实现。</p>\n<p>最后也是最重要的一点是，LLVM还没有对部分通用语言成分给出原语。许多语言都具有某种垃圾回收的内存管理方式，或者是作为管理内存的主要方式，或者作为对 <a href=\"https://en.wikipedia.org/wiki/Resource_acquisition_is_initialization\" rel=\"nofollow\">RAII</a> ( C++ 底层实现的自动垃圾回收，表面使用 Rust 语法）等策略的附属方式。LLVM 并不会给你一个垃圾回收机制，但是它提供了<a href=\"https://llvm.org/docs/GarbageCollection.html\" rel=\"nofollow\">实现垃圾回收的工具</a>，它允许在代码中使用元数据标记，让编写垃圾回收器变得更加容易。</p>\n<p>尽管如此，但是 LLVM 未来还有有可能添加原生的机制来实现垃圾回收机制。LLVM 正在快速发展中，大概 ６ 个月就会有一次大版本的更新。由于当前的许多语言都使用 LLVM 作为开发的核心，因此 LLVM 的迭代速度只会更快而不会放慢。</p>\n\r\n        \r\n        \r\n        \n    <div class=\"post-adds\">\n        <span data-post-id=\"113684\" class=\" btn-bluet-bigger href-style vote-post-up   register-user-only \"><i class=\"fa  fa-thumbs-o-up\"></i> <h10 id=\"113684votetotal\">1</h10> 赞</span>\n        <span data-book-type=\"1\" data-site-id=\"2\" data-item-id=\"113684\" data-item-type=\"1\" class=\" btn-bluet-bigger href-style bookmark-btn  register-user-only \"><i class=\"fa fa-bookmark-o  \"></i> 1 收藏</span>\n\n                    <a href=\"#article-comment\"><span class=\"btn-bluet-bigger href-style hide-on-480\"><i class=\"fa fa-comments-o\"></i>  评论</span></a>\n        \n        \n        \n        <!-- JiaThis Button BEGIN -->\n        <div class=\"jiathis_style_24x24\" style=\"display: inline-flex; position: relative; margin: 0; clear: both;float: right;\">\n            <a class=\"jiathis_button_tsina\"></a>\n            <a class=\"jiathis_button_weixin\"></a>\n            <a class=\"jiathis_button_qzone\"></a>\n            <a class=\"jiathis_button_fb hide-on-480\"></a>\n            <a href=\"http://www.jiathis.com/share?uid=1745061\" class=\"jiathis jiathis_txt jiathis_separator jtico jtico_jiathis\" target=\"_blank\"></a>\n        </div>\n\n    </div>\n\n\n\n\r\n        <!-- BEGIN #author-bio -->\r\n\r\n\r\n<!-- END #author-bio -->\r\n\t</div>", "url": "http://blog.jobbole.com/113684/", "title": "什么是 LLVM？Swift, Rust, Clang 等语言背后的支持", "praise_nums": 1, "favor_nums": 1, "front_image_url": ["http://jbcdn2.b0.upaiyun.com/2018/02/7130c496b853a379b7b91ff9ce0f5a26.jpg"], "url_object_id": "d6b7516ebc1871e25bb3dd9372674165", "creat_date": "2018-02-28"}